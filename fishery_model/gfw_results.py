from .fishery_results import FisheryResultSet, GearGroupResults
from .fishery import generate_fisheries, FisheryModel, EFF_MAP
from .quantile_catch_effort_intensity import proxy_quantities
from .sala_2019 import get_Sala_cluster

from pandas import DataFrame


GFWGears = ('seiners', 'trawlers', 'drifting_longlines')

ProxyGears = ('set_gillnets', )


class ProtoResultSet(GearGroupResults):

    _valid_gears = ()

    def _generate_fisheries(self, **kwargs):
        """
        Must return a list of records that are used to create fisheries in next_fishery
        :param kwargs:
        :return:
        """
        raise NotImplementedError

    @property
    def gear_types(self):
        return {
            'GFWCategory': self._gear
        }

    def models(self, **kwargs):
        """
        Return a list of valid library models, given the gear type and input parameters
        :param kwargs:
        :return:
        """
        return list(self._gml.valid_models(gear_types=self.gear_types, **kwargs))

    def __init__(self, library, gear, **kwargs):
        assert gear in self._valid_gears, 'Invalid gear: %s' % gear
        self._gear = gear
        super(ProtoResultSet, self).__init__()
        self._gml = library

        self._cei = self._generate_fisheries(**kwargs)
        self._matched = []
        self._fail = []

    def __iter__(self):
        return self

    def __next__(self):
        try:
            return self.next_fishery()
        except IndexError:
            raise StopIteration

    def next_fishery(self, **kwargs):
        """
        Must exhaustively process the fisheries generated by _generate_fisheries, either:
         - adding a FisheryModel to self._matched and a matching FisheryResultSet added to _frs, or
         - adding the faulty record to self._fail.
        :param kwargs:
        :return:
        """
        raise NotImplementedError

    def matched(self, i):
        n = self._matched[int(i)]
        return self._frs[self._names[n]]

    @property
    def failed(self):
        return tuple(self._fail)

    def _make_frs_summary(self, frs, **kwargs):
        s = frs.summary()
        n_ves = frs.fishery.n_vessels
        s['gear'] = self._gear
        s['n_vessels'] = n_ves
        s['gear_kg_vessel'] = s['gear_kg'] / n_ves
        s['diss_kg_vessel'] = s['diss_kg'] / n_ves
        s.update(kwargs)
        return s

    def _frs_summary(self, **kwargs):
        for frs in self._frs:
            yield self._make_frs_summary(frs, **kwargs)

    def summary_df(self, **kwargs):
        return DataFrame((k for k in self._frs_summary(**kwargs)))


class GFWResultSet(ProtoResultSet):

    _valid_gears = GFWGears

    def _generate_fisheries(self, **kwargs):
        return list(generate_fisheries(self._gear, gfw=True, catch=True, **kwargs))

    def _prox_unit(self):
        """
        runs once on init
        :return:
        """
        scl = EFF_MAP[self._eff]
        q = next(k1 for k1, k2 in proxy_quantities if k2.lower() == scl.lower())
        return self._gml.get_quantity(q, measure='catch').unit

    def models(self, effort_family=None, **kwargs):
        if effort_family is None:
            effort_family = self.effort_family
        return super(GFWResultSet, self).models(effort_family=effort_family, **kwargs)

    def __init__(self, library, gear, effort_type, tau=None, **kwargs):
        assert effort_type in EFF_MAP, 'Invalid effort: %s' % effort_type
        self._eff = effort_type
        super(GFWResultSet, self).__init__(library, gear, **kwargs)
        self._prox = self._prox_unit()
        self._tau = tau or ''

        self._effort = []

    def _make_frs_summary(self, frs, **kwargs):
        s = super(GFWResultSet, self)._make_frs_summary(frs, **kwargs)
        s['effort'] = self._eff
        s['effort_moment'] = frs.fishery.effort_moment(self._eff)
        return s

    def _frs_summary(self, include_proxy=True, **kwargs):
        for frs in self._frs:
            if not include_proxy:
                if frs.name in self._effort:
                    continue
            yield self._make_frs_summary(frs, **kwargs)

    @property
    def effort_family(self):
        return 'GFW-%s-%s-%s' % (self._gear, self._eff, self._tau)

    @property
    def effort_proxy(self):
        return 'GFW-proxy-%s-%s' % (self._gear, self._prox)

    def g_param(self, fm):
        if self._gear == 'trawlers':
            scl = fm.effort_moment(self._eff)
            return get_Sala_cluster(self._eff, scl)
        return None

    def gfw_only(self, i):
        n = self._effort[int(i)]
        return self._frs[self._names[n]]

    def next_fishery(self, **kwargs):
        cei = self._cei.pop(0)
        if cei['total_catch_gfw_cat'] == 'NA':
            # this no longer occurs- could be removed (??)
            fm = FisheryModel.from_observed_effort(cei, self._eff)
            tgt = self._effort
            models = self.models(effort_family=self.effort_proxy, **kwargs)
            e_param = None
        else:
            fm = FisheryModel.from_catch_effort(cei)
            tgt = self._matched
            models = self.models(**kwargs)
            try:
                e_param = fm.effort_moment(self._eff)
            except ZeroDivisionError:
                print('%s: zero fishing hours' % fm.name)
                self._fail.append(fm)
                return None
        try:
            g_param = self.g_param(fm)
        except ZeroDivisionError:
            print('%s: zero fishing hours' % fm.name)
            self._fail.append(fm)
            return None
        try:
            frs = FisheryResultSet(fm, models, e_param=e_param, g_param=g_param)
        except AssertionError:
            print('%s: assertion error' % fm.name)
            self._fail.append(fm)
            return None
        self.add_fishery(frs)
        tgt.append(fm.name)
        return frs


class ProxyResultSet(ProtoResultSet):

    _valid_gears = ProxyGears

    def _generate_fisheries(self, **kwargs):
        return list(generate_fisheries(self._gear, gfw=None, catch=True, **kwargs))

    def next_fishery(self, **kwargs):
        cei = self._cei.pop(0)
        fm = FisheryModel.from_catch(cei)
        frs = FisheryResultSet(fm, self.models(**kwargs))
        self.add_fishery(frs)
        self._matched.append(fm.name)
        return frs
